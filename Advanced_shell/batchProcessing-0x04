#!/bin/bash

# Parallel Pokemon Data Fetching Script
# Uses background processes and jobs command for process management

# Configuration
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")
API_BASE_URL="https://pokeapi.co/api/v2/pokemon"
OUTPUT_DIR="pokemon_data"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Function to print colored output
print_color() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Function to setup environment
setup_environment() {
    if [ ! -d "$OUTPUT_DIR" ]; then
        mkdir -p "$OUTPUT_DIR"
        print_color "$BLUE" "üìÅ Created directory: $OUTPUT_DIR"
    fi
}

# Function to fetch single Pokemon data (background process)
fetch_pokemon() {
    local pokemon_name="$1"
    local output_file="${OUTPUT_DIR}/${pokemon_name}.json"
    local api_url="${API_BASE_URL}/${pokemon_name}"
    
    print_color "$CYAN" "Fetching data for ${pokemon_name}..."
    
    # Make API request
    if curl -s -f "$api_url" -o "$output_file"; then
        print_color "$GREEN" "Saved data to ${output_file} ‚úÖ"
    else
        print_color "$RED" "Failed to fetch data for ${pokemon_name} ‚ùå"
        return 1
    fi
}

# Function to start all background processes
start_parallel_fetching() {
    print_color "$YELLOW" "üöÄ Starting parallel data fetching..."
    
    # Start background processes for each Pokemon
    for pokemon in "${POKEMON_LIST[@]}"; do
        fetch_pokemon "$pokemon" &
    done
    
    print_color "$BLUE" "üìä Started ${#POKEMON_LIST[@]} background processes"
}

# Function to monitor and wait for all jobs to complete
wait_for_all_jobs() {
    print_color "$YELLOW" "‚è≥ Waiting for all background processes to complete..."
    
    # Show current jobs
    print_color "$BLUE" "üìã Current background jobs:"
    jobs
    
    # Wait for all background jobs to complete
    while [ $(jobs -r | wc -l) -gt 0 ]; do
        print_color "$CYAN" "   Active jobs: $(jobs -r | wc -l)"
        jobs -l
        sleep 2
    done
    
    # Wait for all background processes
    wait
    
    print_color "$GREEN" "‚úÖ All background processes completed!"
}

# Function to display results
show_results() {
    local successful=0
    local failed=0
    
    print_color "$CYAN" "üìä PARALLEL PROCESSING RESULTS"
    print_color "$CYAN" "=============================="
    
    for pokemon in "${POKEMON_LIST[@]}"; do
        local json_file="${OUTPUT_DIR}/${pokemon}.json"
        
        if [ -f "$json_file" ] && [ -s "$json_file" ]; then
            ((successful++))
            local file_size=$(stat -f%z "$json_file" 2>/dev/null || stat -c%s "$json_file" 2>/dev/null || echo "unknown")
            print_color "$GREEN" "‚úÖ $pokemon - Success ($file_size bytes)"
        else
            ((failed++))
            print_color "$RED" "‚ùå $pokemon - Failed"
        fi
    done
    
    echo ""
    print_color "$BLUE" "üìà Summary:"
    print_color "$GREEN" "   Successful: $successful/${#POKEMON_LIST[@]}"
    print_color "$RED" "   Failed: $failed/${#POKEMON_LIST[@]}"
    
    if [ $successful -gt 0 ]; then
        echo ""
        print_color "$BLUE" "üìÅ Output files:"
        ls -la "$OUTPUT_DIR"/*.json 2>/dev/null
    fi
}

# Function to handle script interruption
cleanup() {
    print_color "$YELLOW" "\nüõë Script interrupted! Cleaning up background jobs..."
    
    # Kill all background jobs
    jobs -p | xargs -r kill 2>/dev/null
    
    exit 130
}

# Main execution function
main() {
    # Set up signal handler
    trap cleanup SIGINT SIGTERM
    
    # Display header
    print_color "$CYAN" "üöÄ Parallel Pokemon Data Fetching"
    print_color "$CYAN" "================================="
    print_color "$BLUE" "üìã Pokemon to fetch: ${POKEMON_LIST[*]}"
    print_color "$BLUE" "üìÅ Output directory: $OUTPUT_DIR"
    echo ""
    
    # Check prerequisites
    if ! command -v curl >/dev/null 2>&1; then
        print_color "$RED" "‚ùå curl is required but not installed"
        exit 1
    fi
    
    # Setup environment
    setup_environment
    
    # Record start time
    local start_time=$(date +%s)
    
    # Start parallel fetching
    start_parallel_fetching
    
    echo ""
    
    # Wait for all jobs to complete
    wait_for_all_jobs
    
    # Calculate execution time
    local end_time=$(date +%s)
    local total_time=$((end_time - start_time))
    
    echo ""
    print_color "$BLUE" "‚è±Ô∏è  Total execution time: ${total_time} seconds"
    
    # Show results
    echo ""
    show_results
    
    print_color "$GREEN" "üéâ Parallel processing completed!"
}

# Execute main function
main "$@"